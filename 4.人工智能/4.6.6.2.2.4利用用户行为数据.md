# 利用用户行为数据
## 用户行为数据介绍
### 什么是用户行为数据？
顾名思义，用户行为数据是指一些能表示用户行为的数据，最简单的存在形式就是网站上的日志，包括用户在网站上的点击被记录至点击日志，完成一次网站相应被记录至会话日志等。
### 用户行为数据分类
- 显性反馈数据：显形反馈包括用户明确表示对物品喜好的行为，例如对于一个视频的顶或者踩，更进一步是对于这个视频写下的评价、打上的标签等。

- 隐形反馈数据：隐形反馈包括用户的页面浏览行为等不能明确反映用户兴趣的行为，包括一个视频的完播率，页面的停留时间等数据。

若是按照反馈的划分，数据又可以被分为正反馈和负反馈，正反馈指用户的行为倾向于用户喜欢该物品，而负反馈则相反。

## 用户行为数据分析
### 用户活跃度和物品流行度的关系

**长尾分布** 互联网中很多数据都遵循长尾分布：$f(x)=\alpha x^k$ ，用户行为数据同样蕴含长尾分布的规律。

令 $f_{u}(k)$ 为对 $k$ 个物品产生过行为的用户数，$f_i(k)$ 为对 $k$ 个用户产生过行为的物品数。那么有以下的规律存在
$f_i(k)=\alpha_ik^{\beta_i}，f_u(k)=\alpha_uk^{\beta_u}$ 


## 协同过滤算法
仅对用户行为数据所设计的推荐系统算法被称为协同过滤算法。协同过滤算法中包含多种算法：基于邻域的方法、隐语义模型、基于图的随机游走算法。
### 基于邻域的算法
推荐系统中最基本的算法，可以分为基于用户的协同过滤盒基于物品的协同过滤。

#### 基于用户的协同过滤

算法简介：当你想要出去玩时，你会询问身边和自己游玩兴趣相似的朋友的意见，并从他们的推荐中选择你自己的出行方案，而且一般你制定的出行方案中大部分是自己为听说过或去玩过的景点，这就是一种生活中的基于用户的协同过滤。

特点分析：可以从上面的例子看出，此类协同过滤主要包含两个步骤：

**(1)找到和目标用户相似的用户集合** ，我们称这个被找到的用户为，被寻用户以方便下文讲解 

**(2)从被寻用户的兴趣集合中，找到目标用户喜欢的且目标用户未听说过的物品** 

以上就是，基于用户的协同过滤最基本的思想，让我们分步对这个算法进行分析。

#### 如何找到和目标用户相似的被寻用户？

关键就是计算用户与用户之间的相似度，计算相似度有两种不同的方法，我们给定用户 $u$ 和用户 $v$ ，$N(u)$ 为用户 $u$ 有过正反馈的物品集合，$N(v)$ 为用户 $v$ 有过正反馈的物品集合。

**Jaccard 相似度** 公式为：$w_{uv} = \frac{\vert N(u)\cap N(v)\vert}{\vert N(u)\cup N(v)\vert}$ 

**余弦相似度** 公式为：$w_{uv} = \frac{\vert N(u)\cap N(v)\vert}{\sqrt{\vert N(u)\vert \vert N(v)\vert}}$ 

这就是一种计算相似度的方法，但是不可避免的，这样的相似度计算方法需要遍历整个用户信息表，时间开销极大，而且存在很多无效查询，所以考虑进行改进。**倒排表改法？**

用户相似度在遭遇热门物品时，会导致严重的误差，例如：如果两人同时购买了《新华字典》，可能并不是因为两人都对它有兴趣，而是因为它是一本基本工具书，所以不能通过这个过热门物品确定二人的兴趣相似。**改进公式惩罚热门物品？**

#### 如何为目标用户推荐物品？

关键是计算出目标用户对于各个物品的兴趣，设 $S(u,K)$ 包含和用户 $u$ 最接近的 $K$ 个用户，$N(i)$ 是对物品 $i$ 有过行为的物品集合，$w_{uv}$ 表示用户 $u 和 v$ 的兴趣相似度，$r_{vi}$ 表示用户 $u对i$ 的兴趣，这个变量的值仅有01取值。

所以用户$u对于物品i的相似度$ 可表示为：$p(u,i)=\sum_{v\in S(u,K)\cap N(i)}{w_{uv}r_{vi}}$ 

其中会对这个推荐结果产生较大影响的外部变量，$K$。如何确定一个合适的K值是？

#### 基于物品的协同过滤算法

算法简介：例如你以前购买过《算法导论》，而系统判断《算法导论》与《数据结构》具有较高的相似度，那么系统就会将《数据结构》推荐给你，需要注意的是，系统对于物品之间相似度的判定，来源与用户对于物品的行为信息，而不是根据物品与物品之间内容的相关性。

特点分析：**较高的解释性**，系统在进行推荐时，可以利用用户的历史行为给推荐结果提供解释；**较低的时间复杂度**，相较于基于用户协同过滤的和用户数量成平方的时间复杂度，基于物品协同过滤的时间复杂度较低。

该算法与用户协同过滤类似，分成两步：

**计算物品之间的相似度**，定义$N(i)$ 是喜欢物品 i 的用户数， $N(i)\cap N(j)$ 为喜欢物品 i 和 j 的用户数，因此物品相似度可定义为如下公式

<center>

$w_{ij}=\frac{\vert N(i)\cap N(j)\vert}{\vert N(i) \vert}$ 

</center>

同样的，该公式也存在热门物品造成误差的问题，因为如果多数人都喜欢 j ，那么 $w_{ij}$ 就会无限趋近于1，导致系统中任何物品对于物品j都具有很大的物品相似度，影响了推荐系统的覆盖率，所以考虑对于公式进行修正为

<center>

$w_{ij}=\frac{\vert N(i)\cap N(j) \vert}{\vert N(i)\vert \vert N(j)\vert}$ 

</center>

**用户活跃度对于相似度的影响？** 如果一个批发商大肆购买物品，那么他对于这大量物品的相似度的实际贡献，是不如一个只购买了十几本书的兴趣爱好者的。那么，**如何对这种行为进行惩罚？**

更进一步，**归一化？**，将相似度矩阵按最大值归一化，可以有效提升推荐系统的性能。

#### 得到用户对于物品i的兴趣

同样通过相似度对于兴趣进行推测，$N(u)$ 表示用户喜欢的物品集合，$S(j,K)$ 是和物品 j 最相似的 K 个物品集合，$w_{ij}$ 是物品 i 和物品 j 的相似度，$r_{ui}$ 是用户 u 对于物品 i 的兴趣（根据隐反馈数据集，若用户对于物品有过行为，则值为1），所以公式为
<center>

$P_{uj}=\sum_{i\in N(u)\cap S(j,K)}{w_{ji}r_{ui}}$   

</center>


## 隐语义模型
隐语义模型的基本思想是，通过隐含特征联系用户兴趣和物品，进行进一步解释即为：以物品的内容进行分类，根据用户的行为对用户进行兴趣判断，从对应符合用户兴趣的物品类别中推荐物品。

基于上述理解，需要解决的问题分别有：

(1)如何对于物品进行分类；

(2)如何确定用户的兴趣方向，以及用户对于不同兴趣方向的感兴趣程度；

(3)对于一个兴趣方向，如何挑选给定分类中的物品给用户，如何确定该物品在分类中的权重。

为了解决上述问题，以及上述问题牵扯出的一系列问题(思考这一系列问题中有哪些？是个很好的锻炼思维方式)。考虑采用隐含语义分析技术，因为**隐含语义分析技术**采取基于用户行为统计的自动聚类，具有对于以上问题较好的适应性。

类似于itemCF的思想，若两件物品同时被很多用户标记，则这两件物品可能属于统一分类

隐语义能够指定最终的分类数量，从而控制分类的粒度，当分类数量较大时，粒度则较小，分类数量较小时，粒度较大

隐语义会计算出单个物品不同内容的所占权重，所以不会出现一个物品只在一个分类中

隐语义所给出的分类是基于用户共同兴趣的，所以给出的分类有更大可能会给予不同维度

隐语义通过统计用户的行为来确定物品在当前分类的权重

#### LFM模型

###### 建立数据集

用户所产生的行为分为正反馈与负反馈，LFM模型在显性反馈数据集上解决评分预测问题有很好的精度，但是若是在隐性反馈数据集上，样本只存在正样本而没有负样本，如何解决这个问题，**生成令人满意的负样本？**

生成负样本有如下的几种思路

定义用户未有过行为的物品、定义未有过行为中随机采样出的物品、定义未有过行为中随机采样出的物品，且这些物品数量与正样本数量相当、定义未有过行为的物品，且着重挑选一些不热门的物品。

在实际实验的过程中，上述四种思路各有胜负，最终通过一场2011年的推荐算法比赛，得出了负样本采样应遵循的原则

- 负样本采样应保证正负样本平衡

- 采取负样本时，应遵循冷门物品有限的原则

#### 通过随机梯度下降法优化参数

通过建立的数据集 $K=\{(u,i)\}$ ，其中如果 $(u,i)$ 是正样本，则有 $r_{ui}=1$ 否则为0。然后通过优化如下的损失函数来找到合适的参数 $p,q$ 

$$C=sum_{(u,i)\in K}{(r_{ui}\hat r_{ui})^2}=\sum_{(u,i)\in K}{(r_{ui}\sum^K_{k=1}{p_{u,k} q_{i,k} })^2}+\lambda\Vert p_u\Vert^2+\lambda\Vert q_i\Vert^2$$

其中，$\lambda\Vert p_u\Vert^2+\lambda\Vert q_i\Vert^2$ 是用来防止过拟合的正则项，$\lambda$ 可通过实验获得。

使用随机梯度下降法优化以上的损失函数，递推公式如下：

$p_{uk}=p_{uk}+\alpha(q_{ik}\lambda p_{uk})$ 

$q_{ik}=q_{ik}+\alpha(p_{uk}\lambda q_{ik})$

重要参数共四个：

- 隐特征数量F

- 学习速率$\alpha$

- 正则化参数$\lambda$

- 负样本与正样本的比例ratio

将得到的参数代入Preference公式中

LFM定义了 $p_{u,k}$ 和 $q_{i,k}$ 作为模型的参数，其中，$p_{u,k}$ 度量了用户 u 的兴趣和第 k 个隐类的关系，而$q_{i,k}$ 度量了第 k 个隐类和物品 i 之间的关系，所以可以有公式计算兴趣度

<center>

$$Preference(u,i)=r_{ui}=p^T_uq_i=\sum^F_{f=1}{p_{u,k}q_{i,k}}$$

</center>

得到用户对于物品的兴趣度之后，就能进行排名再生成推荐列表。

#### LFM局限性

对于参数的训练的要再数据集上进行多次迭代，在一般的实际应用中每天只能训练一次并且得出结果，所以很难满足根据用户的实时行为对用户进行推荐，即实时性较弱。

## 基于图的模型

可以想到用户与物品之间的相互关系可以由二分图进行表示，所以在推荐算法中引入图模型
### 用户数据的二分图表示

在研究图模型之前，需要用已有的数据生成一个图，设二元组 $(u,i)$ 表示用u对于物品 i 产生过行为。令 $G(V,E)$ 表示用户物品二分图，其中$V=V_U\cup V_I$ 由用户顶点集合和物品顶点集合组成，$E$ 是边的集合。对于数据集中的二元组 $(u,i)$ 图中都会有对应的边 $e(v_u,v_i)\in E$ 如下图所示。

![用户物品二分图模型](https://cdn.xyxsw.site/用户物品二分图模型.png)

### 基于图的推荐算法

将数据集转换为图模型之后，原来的给用户u推荐物品的任务就可以等效于计算与用户u没有边直接相连的物品集合中，计算用户与物品的相关性，相关性越高则它在推荐列表中的权限就越高。

#### 相关性计算

相关性的计算主要依赖于一下三个因素

1. 两个顶点间的路径数

2. 两个顶点之间的路径距离

3. 两个顶点之间的路径经过的顶点

相关性高的两个顶点，通常具有以下的特征

1. 两个顶点之间有很多路径相连

2. 连接两个顶点间的路径很短（相似度高）

3. 连接两个顶点之间的路径不会出现出度过大的顶点（热门物品少）

**PersonalRank算法**

基于上述相关性计算的因素，有多种多样不同侧重的图算法，下面将介绍一种基于随机游走的PersonalRank算法

PersonalRank算法的基本思想是，假设要给用户u进行个性化推荐，可以从用户节点 $v_u$ 开始在用户物品二分图上开始随机游走。当游走到一个节点是，首先按照概率$\alpha$ 决定是继续游走，还是停止游走并直接返回 $v_u$ 重新开始游走。如果决定继续游走，那么就从当前节点所指向的节点按照均匀分布随机选取一个节点作为下次游走的目标。这样，经过多轮游走之后，每个物品节点被访问到的概率会收敛到一个数。最终推荐列表的权重就是这个点的访问概率。

可表示为公式 
$$
PR(v)=\begin{cases}\alpha \sum_{v'\in in(v)}\frac{PR(v')}{\vert out(v')\vert},&v\ne v_u\\(1\alpha)+\alpha \sum_{v'\in in(v)}\frac{PR(v')}{\vert out(v')\vert},&v=v_u\end{cases}
$$

与上面几种算法一样，PersonalRank算法需要在全图迭代，所耗费的时间是难以接受的，如何改进算法？

1. **减少迭代次数** 

2. **通过矩阵论重新设计算法** 

## 总结
在本节内容中，我们主要立足于用户的行为数据，介绍用户行为数据是什么？用户行为数据有哪些分类？用户行为数据的特点。并且通过用户对于物品产生行为数据这一活动，我们设计了一系列算法包括，基于邻域算法、隐特征模型、基于图的模型。

但是用户对于物品产生数据这一行为，在当今互联网上算是最为简单的一种交互，无法满足用户日益刁钻的推荐需求。反过来思考，一旦当系统是一个新上线的系统，还没有大量的数据信息进行训练参数时，如何进行推荐。这就是后面我们主要解决的两个问题

如何解决冷启动问题？

如何增加推荐因素以满足用户增长的推荐需求？